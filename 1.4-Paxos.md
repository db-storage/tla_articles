#  共识系列之Paxos篇

---

### 与Voting.tla的主要不同点

### 增加的变量

```tla
         maxVBal, \* <<maxVBal[a], maxVal[a]>> is the vote with the largest
         maxVal,    \* ballot number cast by a; it equals <<-1, None>> if
                    \* a has not cast any vote.
         msgs     \* The set of all messages that have been sent.
 (*假设a Vote过的ballot number最大选票为(b, v)，那么<<maxVBal[a] , maxVal[a]>> = <<b, v>> *)
(* msgs 保存所有发送过的消息，不删除。发送操作就是往集合里面增加一个消息 *)
Send(m) == msgs' = msgs \cup {m}

```

```
 (* Phase1a 和 Phase1b，是Proposer 保证ShowsSafeAt(Q, b, v)的过程，即先给各个Acceptor发送phase1a消息，然后收集它们的Vote。只有形成一个quorum，才能满足ShowSafeAt条件*)
Phase1a(b) == /\ Send([type |-> "1a", bal |-> b])
              /\ UNCHANGED <<maxBal, maxVBal, maxVal>>
                 
(***************************************************************************)
(* Upon receipt of a ballot b phase 1a message, acceptor a can perform a   *)
(* Phase1b(a) action only if b > maxBal[a].  The action sets maxBal[a] to  *)
(* b and sends a phase 1b message to the leader containing the values of   *)
(* maxVBal[a] and maxVal[a].                                               *)
(***************************************************************************)
(* Acceptor a 只有当m.bal >maxBal[a]时，才能vote，这样在收集到一个Quorum的vote后，
*)
Phase1b(a) == /\ \E m \in msgs : 
                  /\ m.type = "1a"
                  /\ m.bal > maxBal[a]
                  /\ maxBal' = [maxBal EXCEPT ![a] = m.bal]
                  /\ Send([type |-> "1b", acc |-> a, bal |-> m.bal, 
                            mbal |-> maxVBal[a], mval |-> maxVal[a]])
              /\ UNCHANGED <<maxVBal, maxVal>>
```



```tla
(* Proposer 在收集回复后，根据消息，来判断是否存在一个Quorum，使得ShowSafeAt(Q, b, v)
   成立。由于Proposer没法直接去查看Acceptor的内存状态，只能通过返回的Phase1b消息来判断有个Quorum满足。
   先定义Q1b是BN匹配的phase1b消息，Q1bv是对应的消息中的value。
(*  从回复的reply中，找到最大的被投票过的Ballot和Value，即对应Voting.tla中的c和v。*)
   *)
Phase2a(b, v) ==
  /\ ~ \E m \in msgs : m.type = "2a" /\ m.bal = b
  /\ \E Q \in Quorum :
        LET Q1b == {m \in msgs : /\ m.type = "1b"
                                 /\ m.acc \in Q
                                 /\ m.bal = b}  (*m.bal表示acceptor在赞同哪个Ballot*)
            Q1bv == {m \in Q1b : m.mbal \geq 0} 
                (* m.mbal acceptor赞成过的最大BN， -1表示没赞成过任何BN *)
        IN  /\ \A a \in Q : \E m \in Q1b : m.acc = a 
            /\ \/ Q1bv = {}  
                 （* 或者 Q1bv 为空，对应ShowsSafeAt的 c == -1的场景, *)
                  (* 表示所有的acceptor都没有赞成过任何ballot，一纸空白*)
               \/ \E m \in Q1bv : 
                    /\ m.mval = v  (* m是一个phase2b m.mval = v *)
                    /\ \A mm \in Q1bv : m.mbal \geq mm.mbal  
                   (*或者Q1bv非空，对应ShowsSafeAt的c != 1的场景      *)
                   (* c = m.mbal, v设置为m.mbal                      *)
  /\ Send([type |-> "2a", bal |-> b, val |-> v])
  /\ UNCHANGED <<maxBal, maxVBal, maxVal>>
  
  
  (* phase2b的判断条件非常简单，只要m.bal >= maxBal[a]即可，*)
 （* ShowsSafeAt(Q, b, v)在 phase1a 时已经保证了.          *) 
  Phase2b(a) == \E m \in msgs : /\ m.type = "2a"
                              /\ m.bal \geq maxBal[a]  
                                 (*对应VoteFor(a, b, v) 里面的 maxBal[a] \leq b*)
                              /\ maxBal' = [maxBal EXCEPT ![a] = m.bal] 
                              /\ maxVBal' = [maxVBal EXCEPT ![a] = m.bal] 
                              /\ maxVal' = [maxVal EXCEPT ![a] = m.val]
                              /\ Send([type |-> "2b", acc |-> a,
                                       bal |-> m.bal, val |-> m.val]) 
```



### 增加的操作：



### Voting TLA里面的rules

[视频](https://youtu.be/8-Bc5Lqgx_c?t=2069)

- Don't allow  different acceptors to vote for diffrent values in the same ballot
=> 如何做到OneValuePerBallot？ Each ballot has a unique leader process(具体leader是谁不重要)
- Allow an acceptor to vote for value v in ballot b only if v is safe at b

每个ballot的phase2a message，只会发送一次，所以同一个ballot，不可能有两个 value。
```tla
(* The first conjunct of Phase2a(b, v) asserts that at most one phase 2a   *)
(* message is ever sent for ballot b.  Since an acceptor will vote for a   *)
(* value in ballot b only when it receives the appropriate phase 2a        *)
(* message, the phase 2a message sent by this action this ensures that     *)
(* these two enabling conjuncts of VoteFor(a,b,v) will be true forever:    *)
```
=>
下面这个检查，在数学上是可以保证一个ballot的phase2a不会发送两次。但是工程上如何实现呢？

```tla
  /\ ~ \E m \in msgs : m.type = "2a" /\ m.bal = b
```

事实上，一个消息在msgs里面，被一个acceptor处理了多次，也是一样的。发送多次不是问题，==处理多次才可能产生问题。==

### 关于msgs 

- 虽然msgs看起来是个保留所有消息的集合，但是这是数学表示。工程师们懂得如何避免保存所有的msg。


> 其Inv，保证的主要是1a, 1b, 2a, 2b各个消息的基本特性。而不是从全局角度考虑。

### Paxos 如何保证VoteFor需要满足的条件？
- VoteFor的后三个条件2-4，都满足了？
```tla
(* In the Phase2a(b, v) action, the ballot b leader sends a type "2a"      *)
(* message asking the acceptors to vote for v in ballot number b.  The     *)
(* enabling conditions of the action--its first two conjuncts--ensure that *)
(* three of the four enabling conditions of action VoteFor(a, b, v) in     *)
(* module Voting will be true when acceptor a receives that message.       *)
(* Those three enabling conditions are the second through fourth conjuncts *)
(* of that action.                                                         *)
```
### 有leader的Paxos/Raft，如何做到 OneValuePerBallot?
- Ballot实际上对应了Term
- 利用Quorum的特性，每次当选后，必然对应了不同的term
- 只有在未Commit的窗口的哪些，需要重新走Phase 1，窗口之后的，直接走Phase 2即可，因为没有走过Phase 1，再执行一遍，肯定得到返回值都是空值。


### 为何phase1b和phase2b都要设置maxBal[a]?
=> 因为answer phase1b的acceptor，不一定是accept 2b的。两个Quorum可以不同。
Lamport的[回答也如此](https://youtu.be/8-Bc5Lqgx_c?t=4175)

- [x] TLA toolbox实际运行，是不是会出现僵局？ 怎么让状态变得有限？
- 实际运行时，配置的Ballot有限(MCPaxos里面)，到时候自然结束了
  
### 如何实现 Voting?
[视频这一段开始](https://youtu.be/8-Bc5Lqgx_c?t=4384)
在paxos里面，定义Votes 为对应的 phase 2b Message

# 附录：Lamport视频的一些摘要

## 为什么需要形式化？

- 在写代码之前，应该从数学的角度，知道自己要做什么。
- 用数学去表示，是最准确的

## 关于Fault Model

- Don't think about what may go wrong
- Think what **must** go right
- 我的理解：以消息为例不用考虑收不到，考虑收到了消息会怎么样。

# 思考

- 如何避免串行化？ 怎么把多个操作，合并为一个paxos消息？
- 这个对于分布式系统(raft也是)，非常有帮助。

  


## 用msgs这种集合，按集合中存在的消息处理，而不是挨个发送，挨个处理，有什么好处？
-  我觉得健壮性更强：因为消息接收者不一定按照发送顺序去处理，而是任何可以看到的消息。后发送的可能先被处理，先发送的可能没被处理。

# 尝试做点改动

## 哪些需要持久化？

### 随机的消息丢失，maxBal等不丢失

丢失的不是最新的，而是随机的

### maxBal, maxVBal随机丢失

### maxBal, maxVBal等不一致

如果持久化了maxBal等，那么msg还需要持久化么？

