#                                                            分层理解Paxos的TLA+ Spec

---

[TOC]

# 1. 简介



关于Paxos和CAP这些理论已经有很多介绍，本文的重点不是Paxos协议本身。而是是顺着Lamport的思路，即如何用形式化的方法，把Consensus => Voting => Paxos这条线给理清楚。也顺便学习下图灵奖获得者是如何逐层抽象和思考的。

本文档的内容主要有以下两个来源，以及一些个人见解。

1) Lamport[讲解Paoxs TLA+的视频](http://lamport.azurewebsites.net/tla/paxos-algorithm.html?back-link=more-stuff.html#paxos?unhideBut@EQhide-paxos@AMPunhideDiv@EQpaxos)。Lamport在其中解释了他当年就是沿着这个思路来思考的并逐步演变出Paxos的，虽然当时没有TLA+。

2）Paxos的TLA+ Spec，[github链接](https://github.com/tlaplus/Examples/tree/master/specifications/Paxos)。Paxos的Spec实际上包含了三个文件：Consensus.tla、Voting.tla 和Paxos.tla

# 2. 用数学定义 Consensus

## 2.1 简介

**Consensus**这个词，经常被翻译为“一致”，我认为“一致”这个词，含义太多了。而“共识”这个词更为贴切，后续都会用这个词。

什么是共识？怎么用数学去形式化地描述共识？Consensus.tla 就是对Consensus这个概念的准确的形式化描述，它实际上就是在描述概念本身。没有任何实现。

简单来说：达成共识，就是选定了一个值(A value is chosen)，一旦选定不可更改。

考察Consensus的TLA，大家我们会发现：

- 状态机一共只有初始状态和选定两个状态，无其他状态； 
- 没有体现参与者、Quorum、Proposal、投票这些过程，只描述了Choose这一个动作
- 共识自身的含义是通过Safety来体现的

## 2.2 Consensu.tla 解析

==如果Spec内容没有高亮显示，请用浏览器打开==

下面把 Consensus.tla 分段解析。在没有讨论TLAPS之前，我们跳过spec中的理论证明(THEOREM)部分。

### 2.2.1 模块和常量定义部分

- MODULE名字，必须跟文件名相同
- EXTENDS类似于代码中的Import/Include
- CONSTANT Value，Value是个候选值集合，在运行Model Check时，可以预先配置。
- chosen也是一个集合，它是个变量，在Model Check过程中可以被修改

```
----------------------------- MODULE Consensus ------------------------------ 
EXTENDS Naturals, FiniteSets
CONSTANT Value 
VARIABLE chosen
```

### 2.2.2  类型约束、状态变更

- TypeOK: 类型检查，chosen必须是Value的子集,并且是有限集
- Init: 初始状态，满足条件：chosen = {}
- Next包含两部分：使能条件和状态变更。使能条件是chosen = {}，状态变更是：从集合Value中找一个值v，构造单元素集合[v}，在下一个状态，满足chosen = [v}。注意，只有使能条件成立时，执行到状态变更。
- Spec: 这个是标准形式，允许Stuttering step，即所有变量都不变化。当然，这里只有chosen一个变量。

```
TypeOK == /\ chosen \subseteq Value
          /\ IsFiniteSet(chosen) 
Init == chosen = {}

Next == /\ chosen = {}
        /\ \E v \in Value : chosen' = {v}

Spec == Init /\ [][Next]_chosen 
```

### 2.2.2  Safety和Liveness

- Inv: Safety约束，**也是Consensus的含义的核心**：为空，或者只有一个值。Cardinality是集合的度，即元素个数。
- LiveSpec: WF是Weak Fairnress，即如果Next的使能条件一直成立，那么Next的状态变更，最终一定有机会执行

```tla+
Inv == /\ TypeOK
       /\ Cardinality(chosen) \leq 1
LiveSpec == Spec /\ WF_chosen(Next)  
```



## 2.3 对 Consensu.tla 执行 Model Check



## 2.4 思考

- Safety的定义是准确的么？是否还有满足Safety，但是却违背了共识的含义的场景？
- 试着改变下Next，用其他方式修改chosen，但是却能保持 Cardinality(chosen) = 1?

# 3. 推理篇：Voting.tla



### 疑问

下面的ShowSafeAt，并没有要求maxBal[a]<=b，而是>=b，那么怎么阻止小的Ballot去形成决议呢？

```
ShowsSafeAt(Q, b, v) == 
  /\ \A a \in Q : maxBal[a] >= b
```

- 可能不是阻止形成决议，而是阻止形成v以外值的决议？相同v，是允许继续形成决议的。

==虽然要求Quorum的 maxBal[a] >= b，但是VoteFor时，必须有maxBal[a] <= b。这样就只可能为b形成决议，而 < b的x，VoteFor 不会被执行。==

```
VoteFor(a, b, v) ==
    /\ maxBal[a] =< b
```

### 只考虑Voting的TLA，它可以做model check，那么OneValuePerBallot 是怎么保证的？

> 参加VoteFor的条件，实际上是检查了的，但是paxos不是真么保证的。

```
VoteFor(a, b, v) ==
 ...
    /\ \A c \in Acceptor \ {a} : 
         \A vt \in votes[c] : (vt[1] = b) => (vt[2] = v)
```

### 有没有类似于Phase1的操作？

> 有，就是 IncreaseMaxBal。但是非常简要，纯数学表示

- 如果没有这个步骤，那么就没法取得进展了。因为 ShowsSafeAt就需要各个Acceptor的 maxBal[a]>=b，就是隐含执行了phase1a

### NoneOtherChoosableAt (b, v) => 现在和将来都不可能用ballot b选定v以外的值。

> SafeAt(b, v) =>所有<=b的 ballot，都不可能选定v以外的值。
> Chosen: 不是一个变量，而是随时计算的得出的。

> 2阶段要保证的各种Safe特性(尤其是外部可见的)，都在Voting中，而不是在Paxos.tla中。 Paxos.tla主要是保证内部的一些特性。

# lamport的最新视频记录

[视频链接](https://www.youtube.com/watch?v=tw3gsBms-f8&feature=youtu.be)

时间点：36:42
- 倒推：为了避免问题，在vote时需要满足：
> Allow an acceptor to vote for value `$v$` in ballot `$b$` only if no value other than `$v$` has been or **ever will be chosen** in any ballot numbered less than `$b$`.

## ever will be chosen怎么保证不发生？
这一块只说了vote，没有说promise之类，那不是voting的内容，那是paxos的内容。这里说的是抽象的保证，但是更加细化了一层的保证。
- Don't allow different acceptors to vote for different values in the same ballot.
- Allow an acceptor to vote for value `$v$` in ballot `$b$` only if `$v$` is safe at `$b$`

- 定义: `$v safe at b$`为
> No value other than `$v$` has been or ever will be chosen in any ballot numbered less than `$b$`.

- Theorem: These conditions imply at most one value can be chosen.

ShowsSafeAt(Q, b, v) 的含义： 只要有一个Qurom 
- 存在一个Q，每个的 maxballot都 >= b
- 存在c, 任意一个a，在c后，都没有再投过票
- 要不都没有vote过，即 c = -1
- 要不然都投过？
- 何时c会是-1? 即b == 0时，即ShowsSafeAt(Q, 0, v)，初始状态。


## 关键部分
1.  ShowsSafeAt(Q, b, v) 与 SafeAt(b, v)的最大不同点：前者只需要Quorum的response，而不需要全部。
2. 如果 ChosenAt(b2,v2)，即v is chosen at, b，如何保证不会发生 ChosenAt(b2,v2), 其中`$b2> b, v2 <> v $` ? 
> 并不需要保证未来，而是在未来Vote(b2, v2)时需要保证 NoneOtherChoosableAt(b2,v2)。这样就顺了。


```(***********************************************
`***************************)
(* This is the theorem that's at the heart of the algorithm.  It shows     *)
(* that if the algorithm has maintained the invariance of Inv, then the    *)
(* truth of ShowsSafeAt(Q, b, v) for some quorum Q ensures that v is safe  *)
(* at b, so the algorithm can let an acceptor vote for v in ballot b       *)
(* knowing VotesSafe will be preserved.                                    *)
(***************************************************************************)
THEOREM ShowsSafety  == 
          Inv  =>  \A Q \in Quorum, b \in Ballot, v \in Value :
                     ShowsSafeAt(Q, b, v) => SafeAt(b, v)
```



### 有了Voting，为什么还需要Paxos?

- 因为它用上帝视角在做vote，VoteFor里面的判断其他人状态、投票都认为是原子操作。但是实际不可能让别的参与者停下来，等待自己干完活。
- Paox把所有的事件看成了异步的。把分布式系统看出是节点和网络组成的异步系统。

> 涉及到投票过程，有了PN的概念。比如，接受PN=n的proposal，不会再接受小于n的proposal。
> 但是没有考虑PN怎么产生的，Value怎么产生的。没有提议过程。从specification的角度，考虑每一步是不是合乎规范。感觉他是在描述 P2C, P2b, P2a等，一步步被满足。



## 4. Paxos的TLA：

### Voting TLA里面的rules
[视频](https://youtu.be/8-Bc5Lqgx_c?t=2069)

- Don't allow  different acceptors to vote for diffrent values in the same ballot
=> 如何做到OneValuePerBallot？ Each ballot has a unique leader process(具体leader是谁不重要)
- Allow an acceptor to vote for value v in ballot b only if v is safe at b

每个ballot的phase2a message，只会发送一次，所以同一个ballot，不可能有两个value。
```
(* The first conjunct of Phase2a(b, v) asserts that at most one phase 2a   *)
(* message is ever sent for ballot b.  Since an acceptor will vote for a   *)
(* value in ballot b only when it receives the appropriate phase 2a        *)
(* message, the phase 2a message sent by this action this ensures that     *)
(* these two enabling conjuncts of VoteFor(a,b,v) will be true forever:    *)
```
=>
下面这个检查，在数学上是可以保证一个ballot的phase2a不会发送两次。但是工程上如何实现呢？
```
  /\ ~ \E m \in msgs : m.type = "2a" /\ m.bal = b
```


### 关于msgs 
- 虽然msgs看起来是个保留所有消息的集合，但是这是数学表示。工程师们懂得如何避免保存所有的msg。


> 其Inv，保证的主要是1a, 1b, 2a, 2b各个消息的基本特性。而不是从全局角度考虑。

### Paxos 如何保证VoteFor需要满足的条件？
- VoteFor的后条件2-4，都满足了？
```
(* In the Phase2a(b, v) action, the ballot b leader sends a type "2a"      *)
(* message asking the acceptors to vote for v in ballot number b.  The     *)
(* enabling conditions of the action--its first two conjuncts--ensure that *)
(* three of the four enabling conditions of action VoteFor(a, b, v) in     *)
(* module Voting will be true when acceptor a receives that message.       *)
(* Those three enabling conditions are the second through fourth conjuncts *)
(* of that action.                                                         *)
```
### 有leader的Paxos/Raft，如何做到OneValuePerBallot?
- Ballot实际上对应了Term
- 利用Quorum的特性，每次当选后，必然对应了不同的term
- 只有在未Commit的窗口的哪些，需要重新走Phase 1，窗口之后的，直接走Phase 2即可，因为没有走过Phase 1，再执行一遍，肯定得到返回值都是空值。


### 为何phase1b和phase2b都要设置maxBal[a]?
=> 因为answer phase1b的acceptor，不一定是accept 2b的。两个Quorum可以不同。
Lamport的[回答也如此](https://youtu.be/8-Bc5Lqgx_c?t=4175)

- [x] TLA toolbox实际运行，是不是会出现僵局？ 怎么让状态变得有限？
- 实际运行时，配置的Ballot有限(MCPaxos里面)，到时候自然结束了
  
### 如何Implement Voting?
[视频这一段开始](https://youtu.be/8-Bc5Lqgx_c?t=4384)
在paxos里面，定义Votes 为对应的 phase 2b Message
# Lamport视频的一些摘要

## 为什么需要形式化？

- 在写代码之前，应该从数学的角度，知道自己要做什么。
- 用数学去表示，是最准确的

## 关于Falut Model

- Don't think about what may go wrong
- Think what **must** go right
- 我的理解：以消息为例不用考虑收不到，考虑收到了消息会怎么样。

# 思考

- 如何避免串行化？ 怎么把多个操作，合并为一个paxos消息？
- 这个对于分布式系统(raft也是)，非常有帮助。

- 

## msgs这种set，而不是挨个发送，挨个处理，有什么好处？
-  我觉得健壮性更强：因为消息接收者不一定按照发送顺序去处理，而是任何可以看到的消息。后发送的可能先被处理，先发送的可能没被处理。

# 尝试做点改动

## 那些需要持久化？

### 随机的消息丢失，maxBal等不丢失

丢失的不是最新的，而是随机的

### maxBal, maxVBal随机丢失

### maxBal, maxVBal等不一致

如果持久化了maxBal等，那么msg还需要持久化么？

