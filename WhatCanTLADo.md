
#### 我实现了一个基于etcd/consul选主的高可用系统，还是使用了lease机制，我如何确定我设计没有漏洞？会不会出现双主呢？

# 为什么需要TLA+


大部分设计，是围绕功能/接口去展开，比如，Cache模块，我们首先想到的是支持Read/Write/Evict这类接口，然后每个接口对应什么流程/数据结构，哪些地方需要临界区保护等。然后我们会脑补各种并发场景，分析可能存在的corner case，然后设计测试用例，运行测试，找bug。

从实现功能的角度，上述做法很正常。但是如果我们考虑下图的一个Cache模型(暂不支持 Evict)，系统实现后，运行了一段时间测试，Read/Write都很正常，所有测试用例都过了。这时候我仍然会有些疑问：

- 有没有Cache 一致性(Coherency)问题？

- 测试能证明没问题了么？

  

### Cache Coherency的例子

这个问题起码可以对应为两个问题：

- Cache Coherency具体是什么？比如下面两个，是不是看起来都正确？

  > 1. 如果某个进程的Cache里面有地址a1的数据，那么Cache里面的数据与主存中地址a1 对应的数据应该是相同的。
  > 2. 如果两个进程的Cache里面都有某个地址a1的数据，那么它们应该是相同的。 

- 如何在运行过程中每一个可能的状态都保证Cache Coherency?

  > 我们不可能在实际系统的代码中不断检查Cache Coherency，但是TLA的Model Checker可以。



### 测试分支覆盖问题

如果把系统运行看出一系列的状态变更，那么问题变成：

- 测试过程中，如何穷举所有可能发生的状态？

  

  

# TLA+能够做什么？

TLA+ 是一种形式化描述语言，使用者用TLA+语言描述自己的算法模型后，使用相应TLC Model Checker工具，来验证模型的正确性。

所谓正确性，实际上包括Safety和Liveness两个方面。最首要的是Safety。

Safety可以认为是系统的设计底线，或者说要保证的内容。例如，对于一个2PC事务，我们要保证的底线：不能有部分参与者认为rollback了，部分认为commit了。至于决策花了多久，各个参与者执行commit/rollback的时间差多少，这是相对次要的问题。

Liveness 是描述系统能够持续运行，比如



下面举几个例子，说明下Safety和Liveness大致是什么。但是每个模型的Safety和 Liveness都是需要使用者自己定义的。

> 后续我们详细解释liveness时会发现，其实liveness里面还包含了公平性在里面，暂时没想到合适的翻译。所以在文中需用Safety和Liveness两个词

| 模型                    | Safety                                                       | Liveness                                                     |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 分布式事务(2PC)         | 考虑单个事务的执行过程，关于commit还是rollback这个决策，必须是一致的。所有参与者、协调者，不能有部分认为commit了，部分认为rollback了，而且也不能先commit，后rollback。 | 一个事务，最终要么commit，要么rollback，不能一直出于未决状态。 |
| 读写锁                  | 不能有两个请求者同时获得了写锁                               | 所有请求，无论读写，最终都能满足(不考虑公平性)               |
| 分布式Key/Value缓存模型 | 如果某节点缓存了某一个key的数据，那么缓存的Value，应该与后端存储是相同的 | 最终每个读请求都能完成                                       |



用上帝的视角，



关于Liveness，wiki上有段解释，参见 [这里](https://en.wikipedia.org/wiki/Liveness)



TLA+ 发现了哪些实际问题？



有哪些模型使用TLA+做了验证

Raft, Paxos



#### 利用TLA+ 验证后的模型，能自动转换成代码么？如何保证代码是正确的？

TLA+实际上只能用于验证关键算法/模型的正确性，不能用于验证完整的系统。TLA+ spec也不能直接转变为代码。

这是因为在验证过程中，model checker需要以广度优先或者深度优先的方式，获得所有可能的状态序列，并验证每个序列的正确性。如果模型中描述的内容过多，可能得状态序列将超出可以计算的范围，验证实际上可能无法完成。所以，一般只在有限规模下验证关键的算法、模型。



#### TLA+ 能验证算法的性能么？

不能



#### 为什么用数学来描述

状态机

穷举所有可达并发序列

​    既然是穷举，我的代码经过长期运行，是否也就完成了穷举？

1. 很难，有些event发生顺序，在现实中很难制造
2. 我们很难确定是否完成了穷举，因为没有上帝视角。比如，你有个集群，各个节点状态，根本没法在瞬间捕获。





